package net.paradise_client.command.impl;

import com.mojang.brigadier.builder.LiteralArgumentBuilder;
import net.minecraft.client.MinecraftClient;
import net.minecraft.command.CommandSource;
import net.minecraft.text.Text;
import net.minecraft.util.Formatting;
import net.paradise_client.command.Command;
import net.paradise_client.helpers.PacketHelper;
import net.paradise_client.utils.OptionType;
import net.paradise_client.utils.OptionUtil;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Locale;
import java.util.Random;

public class CommandsExploit extends Command {
    private static final String COMMAND_NAME = "ContentSpammer";
    private final Random random = new Random();
    private final MinecraftClient mc = MinecraftClient.getInstance();

    // If your Command base requires different constructor args, adjust this accordingly.
    public CommandsExploit() {
        super("ContentSpammer", "Command/Message Spammer");
    }

    public void onExploit(String[] args) {
        if (args == null || args.length < 6) {
            sendChatMessage(Formatting.RED + "Usage: ,commandsexploit <power> <mode> <interval> <content>");
            return;
        }

        int power;
        try {
            power = Integer.parseInt(args[2]);
        } catch (NumberFormatException e) {
            sendChatMessage(Formatting.RED + "Invalid power value. Must be a number.");
            return;
        }

        String mode = args[3].toLowerCase(Locale.ROOT);
        int interval;
        try {
            interval = Integer.parseInt(args[4]);
        } catch (NumberFormatException e) {
            sendChatMessage(Formatting.RED + "Invalid interval value. Must be a number (milliseconds).");
            return;
        }

        String content = args[5].replace("[-space-]", " ");

        sendChatMessage(Formatting.YELLOW + String.format("Sending Exploit... [%s]", getName()));

        if (content.startsWith("/") && mode.equals("command")) {
            content = content.substring(1);
        }
        String finalContent = content;

        new Thread(() -> {
            try {
                for (int i = 0; i < power; i++) {
                    switch (mode) {
                        case "command" -> PacketHelper.sendCommand(finalContent.replace("@r", getRandomName()));
                        case "message" -> PacketHelper.sendChat(finalContent.replace("@r", getRandomName()));
                        default -> {
                            sendChatMessage(Formatting.RED + "Unknown mode: " + mode);
                            return;
                        }
                    }
                    Thread.sleep(interval);
                }
                sendChatMessage(Formatting.GREEN + "Exploit successfully sent!");
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
                sendChatMessage(Formatting.RED + "Exploit interrupted.");
            }
        }).start();
    }

    /**
     * Attempt several likely ways to obtain the online player list from the client network handler.
     * Uses reflection and tolerates differences across mappings/versions.
     */
    private String getRandomName() {
        try {
            List<String> possibleNames = new ArrayList<>();

            Object networkHandler = null;
            try {
                // preferred accessor (mapping-safe)
                networkHandler = mc.getNetworkHandler();
            } catch (Throwable ignored) {
            }

            if (networkHandler != null) {
                // candidate method names that different mappings use
                String[] candidateMethods = new String[]{
                        "getListedOnlinePlayers",
                        "getPlayerList",
                        "getListedPlayers",
                        "getPlayers",
                        "getPlayerInfoList",
                        "getPlayerListEntries",
                        "getProfileList"
                };

                for (String methodName : candidateMethods) {
                    try {
                        Method m = networkHandler.getClass().getMethod(methodName);
                        Object res = m.invoke(networkHandler);
                        if (res == null) continue;

                        // handle Collection / Iterable
                        if (res instanceof Collection) {
                            for (Object entry : (Collection<?>) res) {
                                String name = extractNameFromPlayerEntry(entry);
                                if (name != null) possibleNames.add(name);
                            }
                            if (!possibleNames.isEmpty()) break;
                        }

                        // handle array
                        if (res.getClass().isArray()) {
                            Object[] arr = (Object[]) res;
                            for (Object entry : arr) {
                                String name = extractNameFromPlayerEntry(entry);
                                if (name != null) possibleNames.add(name);
                            }
                            if (!possibleNames.isEmpty()) break;
                        }
                    } catch (NoSuchMethodException ignored) {
                        // try next candidate
                    } catch (InvocationTargetException | IllegalAccessException ignored) {
                    }
                }
            }

            // fallback: try some methods on MinecraftClient that might expose player info
            if (possibleNames.isEmpty()) {
                try {
                    Method[] methods = mc.getClass().getMethods();
                    for (Method m : methods) {
                        if (m.getName().toLowerCase().contains("player") && Collection.class.isAssignableFrom(m.getReturnType())) {
                            try {
                                Object res = m.invoke(mc);
                                if (res instanceof Collection) {
                                    for (Object entry : (Collection<?>) res) {
                                        String name = extractNameFromPlayerEntry(entry);
                                        if (name != null) possibleNames.add(name);
                                    }
                                    if (!possibleNames.isEmpty()) break;
                                }
                            } catch (Throwable ignoredInner) {
                            }
                        }
                    }
                } catch (Throwable ignored) {
                }
            }

            if (possibleNames.isEmpty()) {
                return "xynis";
            }

            String randomName = possibleNames.get(random.nextInt(possibleNames.size()));
            return (randomName == null || randomName.isBlank()) ? "xynis" : randomName;

        } catch (Throwable e) {
            return "xynis";
        }
    }

    /**
     * Helper: given a player-entry-like object (from different mappings), attempt to extract its name.
     * Tries common getter names (getProfile, getName, getGameProfile, getProfileName).
     */
    private String extractNameFromPlayerEntry(Object entry) {
        if (entry == null) return null;
        if (entry instanceof String) return (String) entry;

        String[] getters = new String[]{"getProfile", "getGameProfile", "getProfileName", "getName", "getPlayerName", "getUsername", "getProfileId"};
        for (String getter : getters) {
            try {
                Method gm = entry.getClass().getMethod(getter);
                Object profileOrName = gm.invoke(entry);
                if (profileOrName == null) continue;
                if (profileOrName instanceof String) return (String) profileOrName;
                try {
                    Method getName = profileOrName.getClass().getMethod("getName");
                    Object nameObj = getName.invoke(profileOrName);
                    if (nameObj instanceof String) return (String) nameObj;
                } catch (NoSuchMethodException ignoredInner) {
                    String s = profileOrName.toString();
                    if (!s.isBlank()) return s;
                }
            } catch (NoSuchMethodException | IllegalAccessException | InvocationTargetException ignored) {
            }
        }

        try {
            String s = entry.toString();
            if (s != null && !s.isBlank()) return s;
        } catch (Throwable ignored) {
        }

        return null;
    }

    private void sendChatMessage(String message) {
        if (mc.player != null) {
            // second parameter: actionBar = false (send to chat)
            mc.player.sendMessage(Text.literal(message), false);
        }
    }

    public String getName() {
        return COMMAND_NAME;
    }

    public List<OptionUtil> getOptions() {
        return List.of(
                new OptionUtil("Power", OptionType.INTEGER),
                new OptionUtil("Mode", OptionType.LIST, new String[]{"Command", "Message"}),
                new OptionUtil("Interval", OptionType.INTEGER),
                new OptionUtil("Content", OptionType.MULTIPART)
        );
    }

    public String getArgsUsage() {
        return "power[1], mode[Command], interval[100], content[party xynis]";
    }

    public String getDescription() {
        return "Command/Message Spammer";
    }

    @Override
    public void build(LiteralArgumentBuilder<CommandSource> builder) {
        // optional Brigadier registration can go here.
        // Left empty intentionally â€” registration might be handled by your Command manager.
    }
}
